#!/bin/bash

# CONDITION-LEVEL DEFAULT IMPLEMENTATION ERROR TESTS

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err2.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err3.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err4.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err4=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err5.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err5=$?

err=$((err1+err2+err3+err4+err5))

# CONDITION EXPECTED NEWLINE ERROR TESTS

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl.ned 2>&1 | grep -q "expected newline"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl2.ned 2>&1 | grep -q "expected newline"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl3.ned 2>&1 | grep -q "expected newline"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl4.ned 2>&1 | grep -q "expected newline"
err4=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl5.ned 2>&1 | grep -q "expected newline"
err5=$?

err=$((err+err1+err2+err3+err4+err5))

# TOKEN_LOOP IN CONDITION TEST
# loop token is a bit tricky to create, since the variable chain logic may first
# define it as a variable that then gets replaced with the more specific loop
# token.

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_loop.ned 2>&1 | grep -q "TOKEN_LOOP"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_loop2.ned 2>&1 | grep -q "TOKEN_LOOP"
err2=$?

err=$((err+err1+err2))

# NON-EXTERNAL BOOLEAN TEST VARIATIONS
# \t \t {varchain}
# \t \t !{varchain}
# \t \t {varchain}:=
# \t \t !{varchain}:=
gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_not.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_dflt_impl.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_dflt_impl_not.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err4=$?


err=$((err+err1+err2+err3+err4))


# FINAL SUM 0 CHECK

if [[ $err -gt 0 ]]; then
    exit 1;
fi
