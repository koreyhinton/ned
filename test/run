#!/bin/bash

# CONDITION-LEVEL DEFAULT IMPLEMENTATION ERROR TESTS

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err2.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err3.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err4.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err4=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_dflt_impl_err5.ned 2>&1 | grep -q "default implementation notation is not valid at the condition level"
err5=$?

err=$((err1+err2+err3+err4+err5))

# CONDITION EXPECTED NEWLINE ERROR TESTS

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl.ned 2>&1 | grep -q "expected newline"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl2.ned 2>&1 | grep -q "expected newline"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl3.ned 2>&1 | grep -q "expected newline"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl4.ned 2>&1 | grep -q "expected newline"
err4=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_nl5.ned 2>&1 | grep -q "expected newline"
err5=$?

err=$((err+err1+err2+err3+err4+err5))

# TOKEN_LOOP IN CONDITION TEST
# loop token is a bit tricky to create, since the variable chain logic may first
# define it as a variable that then gets replaced with the more specific loop
# token.

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_loop.ned 2>&1 | grep -q "TOKEN_LOOP"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./cond_exp_loop2.ned 2>&1 | grep -q "TOKEN_LOOP"
err2=$?

err=$((err+err1+err2))

# NON-EXTERNAL BOOLEAN TEST VARIATIONS
# \t \t {varchain}
# \t \t !{varchain}
# \t \t {varchain}:=
# \t \t !{varchain}:=
gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err1=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_not.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err2=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_dflt_impl.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err3=$?

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
./generator ./non_ext_bool_dflt_impl_not.ned 2>&1 | grep -q "TOKEN_VARIABLE_IDENTIFIER(my_bool)"
err4=$?


err=$((err+err1+err2+err3+err4))

# NUM ASSIGNMENT AND DECREMENT TESTS

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
res=$(./generator ./decr_op.ned 2>&1)
echo "$res" | grep -q "TOKEN_DECREMENT(--)"
err1=$?
echo "$res" | grep -q "TOKEN_NUMBER(2)"
err2=$?

err=$((err+err1+err2))

# LONG RUNLINES

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
# ./generator ./ext_str_exec.ned 2>&1
res=$(./generator ./ext_str_exec.ned 2>&1)
echo "$res" | grep -q "TOKEN_EXTERNAL_MODULE(ext_key_value)"
err1=$?
echo "$res" | grep -q "TOKEN_INVALID"
if [[ $? -eq 0 ]]; then
    err2=1 # invert grep q (should not match invalid)
else
    err2=0
fi

gcc -std=c2x ../main.c ../tokenizer.c -o ./generator
# ./generator ./ext_int_exec.ned 2>&1
res=$(./generator ./ext_int_exec.ned 2>&1)
echo "$res" | grep -q "TOKEN_EXTERNAL_MODULE(ext_key_value)"
err3=$?
echo "$res" | grep -q "TOKEN_INVALID"
if [[ $? -eq 0 ]]; then
    err4=1 # invert grep q (should not match invalid)
else
    err4=0
fi

err=$((err+err1+err2+err3+err4))


# FINAL SUM 0 CHECK

if [[ $err -gt 0 ]]; then
    exit 1;
fi
